# 数据库
## 磁盘IO
数据库的宿命是数据的持久化，磁盘 I/O 最终会成为数据库的一个性能瓶颈。  

### 廉价磁盘冗余阵列 (RAID)
根据**数据分布和冗余方式**，RAID 分为许多级别。
RAID 0 **条带化**，按一定的条带大小将数据依次分布到各个磁盘，没有数据冗余；优点是读写速度快，价格低；缺点是无冗余保护，可靠性差。  
RAID 1 **镜像**，两个磁盘为一组，所有数据同时写入两个磁盘中，读可以从任一磁盘读；优点是有安全冗余；缺点时投资比较大。
RAID 10 结合以上两者
RAID 4 在 RAID 0 的基础上额外增加一个磁盘，用来写各 Stripe 的校验纠错数据；有一定的**纠错**能力  
RAID 5 在 RAID 4 的基础上，将校验纠错数据块也分别写到各个磁盘上。  
RAID 6 两颗冗余磁盘，可靠性提升更高。

### I/O 调度算法
1. 寻道：将磁头移动到磁盘表面的正确位置，花费的时间叫寻道时间。
2. 等待磁盘旋转，需要的数据会移动到磁头下面，花费的时间取决于磁盘的转速。  
3. 磁盘继续旋转，直到所有需要的数据都经过磁头。

总时间分为访问时间（步骤1和2）和传输速度，也叫延迟和吞吐量。  
为改善磁盘寻道时间，操作系统将 I/O 请求放入队列，对请求进行合并（相同或相临扇区）和排序（对非相邻扇区，按磁盘旋转方向排序），来减少磁盘寻道操作次数。  

Linux 实现了四种 I/O 调度算法：
1. NOOP(No Operation)不对I/O请求排序，除了合并以外不再优化，用FIFO提交请求。适用于SSD这种随机访问设备，没有传统机械臂的移动所造成的寻道时间。
2. Deadline 最后期限算法：一个拥有合并和排序功能的请求队列，一个读请求队列，一个写请求队列，它们都是带有超时的FIFO队列。新请求被同时插入到两队列中，请求超时时，优先处理这些请求来避免“饥饿”。缺点是当出现大量顺序请求时，无法很好的排序，引发频发寻道。  
3. 预期算法：同样维护了三个队列，但处理完一个请求后等待6ms看是否会有相临扇区的请求，适合写入较多的环境如文件服务器。  
4. 完全公平队列 CFQ：将请求按照进程分别放入进程对应的队列中，以时间片算法为前提，轮转调动队列，默认是从当前队列中取出4个请求处理，然后处理下个队列的4个请求，确保每个进程享有的I/O资源均衡。  

## MySQL 引擎
MyISAM InnoDB DBD MEMORY MERGE CSV ...  
MySQL 5.5 以前默认使用 MyISAM 引擎   
MySQL 5.6 以后默认使用 InnoDB 引擎   

### MyISAM VS InnoDB
1. MyISAM 不支持事务、不支持外键、不支持行级锁
2. MyISAM 支持全文索引，支持数据压缩，空间使用低，内存使用低，批量插入的速度快  
3. MyISAM 访问速度快，适合以 **SELECT 和 INSERT** 为主的应用  
4. 每个 MyISAM 在磁盘上分为三个文件，数据文件、索引文件、表定义文件。其中索引文件和数据文件可以分开放，平均分布IO，获得更快的速度
5. MyISAM 支持三种存储格式：静态（固定长度）表、动态表、压缩表  特点分别是：存储迅速，容易缓存，容易恢复；空间占用少，碎片多，故障恢复难；体积小。
6. InnoDB 写的效率略低，占用空间略大
7. InnoDB 适合并发性高（行级锁），需要支持事务，更新删除操作较多的应用。

### 索引建立原则
1. 在 where 子句和 join 子句后面出现的列上建立索引。
2. 在区分度大的列上才考虑建立索引
3. 使用前缀索引（算法，单调函数）
4. 利用最左索引
5. 额外的索引会占用磁盘空间，**降低写操作性能**，修改表内容会引起索引**更新和重构**


## 数据库设计范式

### 反范式
优点： 降低连接操作的需求，表的数目。  
缺点： 降低修改速度，数据完整性问题，维护多张表。
维护数据完整性的方法：  
	异步： 批处理脚本，积累一定时间后修改。  
	同步： 应用逻辑（事务）来保证；缺点：容易遗漏，需求变化时不易维护。  
	触发器： 实时、易于维护  
	
### 中间表
中间表在统计查询时经常用到，是源表部分数据的深拷贝，可以灵活增加索引或新字段等而不会对源表造成影响；另一方面，又在一定程度上克服了水平分表的缺点。
	
## 连表查询
## 优化查询
### 插入数据
1. 暂时关闭自动提交（InnoDB）
2. 使用多个值表级联的方式 `insert into tbl_name values(),(),()...`
3. 将索引文件和数据文件分在不同的磁盘上存放
4. 调整 bulk_insert_buffer_size
5. load data infile 比 insert 语句快 20 倍

### order by
1. 不要混合升序和降序来使用组合索引
2. where 后与 order by 后关键字要相同

### group by
group by order by null

### or
or 之间的每个条件列都必须用到索引（不能是复合索引）

## 分库分表
### 分库
作用：安全冗余、负载均衡  
TDDL My CAT  

- 相同介质上的分库
1. 同步
读无延迟、写有延迟
2. 异步
读有延迟、写无延迟  
3. 同步＋异步
主库写，同步写至部分从库（多主），异步写至从库。主库越多命中率越高。  
从安全上来看，当一台主库 shutdown 后，使用 PAXOS 算法选择一个新的主库（地理位置上），或是 DBA 人工选一个新的主库（阿里内部的做法）

- 不同介质上的分库
缓存，缓存一致性问题  
数据库成功缓存失败，数据库失败缓存成功，同时成功，同时失败。  
先写缓存还是先写数据库。

### 缓存问题
1. 缓存穿透
使用缓存通常是先检查缓存中是否存在，如果存在直接反返回缓存内容，容果不存在则直接查询数据库然后再缓存，返回结果。  
当查询的key一直不存在时，会造成每次都访问数据库，这时缓存就失去了意义。  
解决方法：1. 生成一个空结果来标识数据修改到期时间，快到时去重新加载数据。2. 使用布隆过滤器，挡掉一定不存在的数据。

2. 缓存并发  
与缓存失效类似，但针对的是非常热点的数据（某一热点key vs 很多key）多个进程查询这一到期的热点数据遇到缓存失效同时查询DB，同时设置缓存，使得缓存频繁更新。 
解决方法：对缓存加锁，只有一个进程去查询DB，其他进程等待。 

3. 缓存失效
高并发时，同时设置了相同过期时间的缓存，当过期时间一到，所有的缓存同时实效，导致压力全都落到了DB上。  
解决方法：分散缓存时间，如随机值

4. 缓存一致性问题
写数据库成功而缓存服务器挂了，这时可以考虑启动一个定时任务监测缓存服务器是否恢复，重试写缓存服务器

### 分表
1. 垂直拆分
在满足第三范式的基础上，把主键和一些常用的列放到一个表里，把主键和另一些不常用的列放到另一个表中。  
垂直拆分使得数据行变小，一个数据页就能存放更多的数据，在查询时会减小 I/O 次数。  
缺点是查询所有数据时需要 join 查询；  
插入新数据也要插入到两张表中？  

2. 水平拆分
根据**一列或多列**的值把数据行放到两个独立的表中。  
使用情境：  
表很大，分割后降低读取数据的压力，也降低索引的层数。（不过数据量增加2～3倍，索引也不过增加1层）  
数据本身的特征，具有独立性；比如：不同地区或不同时期的数据适合水平拆分。  
根据查询频率存放到不同的介质上。  
缺点：需要 union

## 分片分区
## 事务隔离级别
### 锁问题
1. 表锁：开销小，加锁快，不会死锁  
2. 行锁：开销大，加锁慢，会出现死锁  
3. 页面锁：开销中，会死锁，并发度中

有时业务逻辑需要我们手动锁定多张表，来模拟原子性。

- MyISAM 的锁问题
	表共享读锁和表独占写锁之间满足一般规律；
	可支持一定程度上的并发插入，即一个进程在读表的同时，另一个进程在表尾插入；  
	默认读操作优先于写，可以通过参数调节彼此优先级。但结果是要么读优先，要么写优先。大量写和长时间读会产生饥饿现象。一种折中的方式是设置 `max_write_lock_count` 读锁达到某个值后自动降低优先级。
	
- InnoDB 的锁问题
	1. 更新丢失：彼此覆盖 （增加写锁）  
	2. 脏读：读到另一个事务尚未提交的修改  
	3. 不可重复读：读到了另一个事务提交的修改
	4. 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足这一查询条件的新数据  

	更新丢失应该是应用的责任  
	数据库实现事务隔离的方式分为两种：加锁或快照  
	快照不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，又称数据多版本并发控制。（git\svn?）  
	事务隔离需要付出代价，因为它实质上是串行化，与并发是矛盾的。